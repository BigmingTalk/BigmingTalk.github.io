<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Bigming" />



<meta name="description" content="本文总结了编程中常用的排序算法，分析了它们在一般情况，最好情况，最坏情况下的时间复杂度以及它们所需的额外空间复杂度，同时实现了它们的实现代码（所有代码的排序结果都是从大到小），并给出了自己对排序算法的一点思考，以供大家参考，也方便自己日后复习查看。本文中包含的排序算法有冒泡排序（普通实现和递归实现，冒泡改进版本），鸡尾酒排序（含改进版本），选择排序（普通实现和递归实现），插入排序（直接插入排序和二">
<meta property="og:type" content="article">
<meta property="og:title" content="十八般排序算法，样样精通">
<meta property="og:url" content="http://bigmingtalk.github.io/2016/12/17/十八般排序算法，样样精通/index.html">
<meta property="og:site_name" content="Bigming">
<meta property="og:description" content="本文总结了编程中常用的排序算法，分析了它们在一般情况，最好情况，最坏情况下的时间复杂度以及它们所需的额外空间复杂度，同时实现了它们的实现代码（所有代码的排序结果都是从大到小），并给出了自己对排序算法的一点思考，以供大家参考，也方便自己日后复习查看。本文中包含的排序算法有冒泡排序（普通实现和递归实现，冒泡改进版本），鸡尾酒排序（含改进版本），选择排序（普通实现和递归实现），插入排序（直接插入排序和二">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.png">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/Bubble_sort_animation.gif">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/ShakeSort.gif">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/Selection_sort_animation.gif">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/Selection_sort_animation2.gif">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/InsertSort.gif">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/InsertSort2.gif">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/InsertSort3.gif">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/Sorting_shellsort_anim.gif">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/Sorting_shellsort_anim2.gif">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/%E9%94%A6%E6%A0%87%E8%B5%9B1.png">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/%E9%94%A6%E6%A0%87%E8%B5%9B2.png">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/%E9%94%A6%E6%A0%87%E8%B5%9B3.png">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/heapsort_anim.gif">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/quicksort_anim.gif">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/Merge_sort_animation.gif">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E4%BE%8B%E5%AD%90.png">
<meta property="og:image" content="http://oe0nilvpj.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.png">
<meta property="og:updated_time" content="2016-12-27T13:54:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="十八般排序算法，样样精通">
<meta name="twitter:description" content="本文总结了编程中常用的排序算法，分析了它们在一般情况，最好情况，最坏情况下的时间复杂度以及它们所需的额外空间复杂度，同时实现了它们的实现代码（所有代码的排序结果都是从大到小），并给出了自己对排序算法的一点思考，以供大家参考，也方便自己日后复习查看。本文中包含的排序算法有冒泡排序（普通实现和递归实现，冒泡改进版本），鸡尾酒排序（含改进版本），选择排序（普通实现和递归实现），插入排序（直接插入排序和二">
<meta name="twitter:image" content="http://oe0nilvpj.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Bigming" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>十八般排序算法，样样精通 | Bigming</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>



    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5847fbe005a1a560"></script>



    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?d80127bd386ab3b3794886e42674188c";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>


</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Bigming</a></h1>
        </hgroup>

        
        <p class="header-subtitle">爱技术，爱生活。</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="true" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:bigmingtalk@163.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/BigmingTalk" title="GitHub"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AVL/">AVL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B-树/">B*树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B-树/">B+树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B-树/">B-树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B树/">B树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Catalan/">Catalan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DRAM/">DRAM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fibonacci/">Fibonacci</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Integer/">Integer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JCF/">JCF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JNI调用/">JNI调用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object类/">Object类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ROM/">ROM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SRAM/">SRAM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TreeMap/">TreeMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/char类型/">char类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/native-method/">native method</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/private方法/">private方法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/static/">static</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码单元/">代码单元</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码实现/">代码实现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码点/">代码点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/传值/">传值</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/信号/">信号</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/写作/">写作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/划分问题/">划分问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/卡特兰数/">卡特兰数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多路组相联/">多路组相联</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/容器/">容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异常控制流/">异常控制流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/引用/">引用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序/">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/整数/">整数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文件系统/">文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/斐波那契数列/">斐波那契数列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/栈/">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浮点数/">浮点数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深入浅出/">深入浅出</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/直接映射，全相联/">直接映射，全相联</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/磁盘/">磁盘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/符号解析/">符号解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/索引/">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/红黑树/">红黑树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程/">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码/">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚拟存储器/">虚拟存储器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/记忆/">记忆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/进程/">进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/重写/">重写</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/重定位/">重定位</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链接/">链接</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/队列/">队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集合/">集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高速缓存/">高速缓存</a></li></ul>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">爱技术，爱生活。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Bigming</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Bigming</a></h1>
            </hgroup>
            
            <p class="header-subtitle">爱技术，爱生活。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:bigmingtalk@163.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/BigmingTalk" title="GitHub"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-十八般排序算法，样样精通" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/17/十八般排序算法，样样精通/" class="article-date">
      <time datetime="2016-12-17T05:56:25.000Z" itemprop="datePublished">2016-12-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      十八般排序算法，样样精通
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/数据结构与算法/">数据结构与算法</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序/">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>本文总结了编程中常用的排序算法，分析了它们在一般情况，最好情况，最坏情况下的时间复杂度以及它们所需的额外空间复杂度，同时实现了它们的实现代码（所有代码的排序结果都是从大到小），并给出了自己对排序算法的一点思考，以供大家参考，也方便自己日后复习查看。本文中包含的排序算法有冒泡排序（普通实现和递归实现，冒泡改进版本），鸡尾酒排序（含改进版本），选择排序（普通实现和递归实现），插入排序（直接插入排序和二分查找插入排序），希尔排序，锦标赛排序，堆排序，快速排序，归并排序，基数排序，计数排序，桶排序。<br><img src="http://oe0nilvpj.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.png" alt="排序算法总结!"><br><a id="more"></a></p>
<h1 id="排序算法特征"><a href="#排序算法特征" class="headerlink" title="排序算法特征"></a>排序算法特征</h1><p>从不同的排序算法特征看各个排序算法，可以将它们进行不同的分类。排序算法的特征包括：</p>
<ol>
<li>是否是基于比较的排序</li>
<li>排序过程能否全部记录放在内存中完成</li>
<li>排序算法的稳定性</li>
<li>排序算法的时间复杂度</li>
<li>排序算法的额外空间复杂度</li>
</ol>
<h2 id="是否是基于比较的排序算法"><a href="#是否是基于比较的排序算法" class="headerlink" title="是否是基于比较的排序算法"></a>是否是基于比较的排序算法</h2><p>简单而言，基于比较的排序算法就是通过对两个元素进行大小比较来决定两个元素在排序好序列中的相对位置（谁排在前面，谁排在后面）。基于比较的排序算法的平均时间复杂度的下限是O(nlogn)，其中n为序列长度。可以通过决策树模型或者信息熵来证明。基于决策树模型的证明的思路是因为将n个序列构成的决策树的叶子节点个数至少有n!，因此高度至少为nlogn。而非基于比较的排序算法的平均时间复杂度则可以做到更好，比如O(n)，即线性时间内完成排序。当然，这些线性时间排序往往需要对输入序列做一些假设，比如计数排序往往对于待排序列的数字范围有一个要求，不能过大，否则可能会造成排序失败。而从更本质上来看，这些线性时间排序往往是利用了空间换时间的思想，通过多出来的额外空间来减少排序时间。</p>
<h2 id="排序过程能否全部记录放在内存中完成"><a href="#排序过程能否全部记录放在内存中完成" class="headerlink" title="排序过程能否全部记录放在内存中完成"></a>排序过程能否全部记录放在内存中完成</h2><p>如果在排序过程中，全部记录都需要放在内存中完成，则称为内排序，否则称为外排序。常见的内排序算法有：冒泡排序，选择排序，插入排序，希尔排序，快速排序等。常见的外排序则有归并排序等。这里要注意的一点是这里区分内排序和外排序是能不能全部记录放在内存中完成，而不是是不是。所以当数据量小的时候，外部排序算法当然可以只利用内存完成排序过程。但是当数据量足够大而内存都不够存储时，则外部排序算法依然可以完成排序过程，而内部排序算法则无法完成排序工作。当然，现实中当数据量足够大时，往往会同时用内排序和外排序来完成排序，简单的思路就是讲数据划分为几块，每块都可以在内存中利用内排序算法完成排序，然后在用归并排序的思想完成所有数的排序。</p>
<h2 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h2><p>排序算法稳定性的简单形式化定义为：如果A<sub>i</sub> = A<sub>j</sub>，排序前A<sub>i</sub>在A<sub>j</sub>之前，排序后A<sub>i</sub>还在A<sub>j</sub>之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。对于不稳定的排序算法，只要举出一个实例，就可以说明它是不稳定的；而对于稳定的排序算法，则必须对算法进行分析并证明其稳定性。</p>
<p>排序算法的稳定性也是由具体的算法来决定的，不稳定的排序算法某种条件下可以变为稳定的排序算法，稳定的排序算法也可以在某种条件下变为不稳定的排序算法。最简单的例子就是冒泡排序，冒泡排序原本是稳定的算法，但是若将两两比较的条件换为arr[j] &lt;= arr[j + 1]，而不是arr[j] &lt; arr[j + 1]，也就是在两个元素相等时交换位置，那么这个改版的冒泡排序就变成了不稳定的。</p>
<p>为什么排序的稳定性很重要？在初学时会觉得两个相等的元素在排序后调换了一下位置会有什么问题吗?其实有时候真的很重要。如果排序算法是稳定的，那么从一件键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键所用。后面会讲的基数排序就是这样的，先按低位排序，逐次按高位排序，低位排序后的相对顺序在高位相同时不会改变。</p>
<h2 id="排序算法的时间复杂度"><a href="#排序算法的时间复杂度" class="headerlink" title="排序算法的时间复杂度"></a>排序算法的时间复杂度</h2><p>排序算法的时间复杂度可以简单地分为平均时间复杂度，最好情况时间复杂度和最坏情况时间复杂度。之所以这么分是因为对于不同特征的待排序列，哪怕两个排序算法的平均时间复杂度是一样的，它们的排序时间可能也会有很大的不同。所以了解每个算法的思想，并知道其在什么特征的待排序列上能有更好的时间复杂度，在什么特征的序列上会出现很差的时间复杂度是很重要的。因为现实生活中往往很多待排序序列会有其特征，而不是随机排列的。所以针对这种特征的待排序序列，我们可以选择相应的排序算法予以解决。</p>
<h2 id="排序算法的额外空间复杂度"><a href="#排序算法的额外空间复杂度" class="headerlink" title="排序算法的额外空间复杂度"></a>排序算法的额外空间复杂度</h2><p>若排序算法的额外空间复杂度为O(1)，我们称之为In-palce排序算法，否则称之为Out-place排序算法。常见的In-place排序算法有：冒泡排序，选择排序，插入排序，堆排序，快速排序等。而常见的Out-place排序算法有：归并排序，计数排序，基数排序，桶排序等。当需要对大量数据进行排序时，In-place排序算法的优势就很明显了，因为其不占用或占用常数内存的空间，而Out-place则需要很大的额外内存空间。</p>
<p>总而言之，言而总之，对于任意一个排序算法，我们所需要思考的几个主要问题有：</p>
<ol>
<li>每个排序算法的思想是什么？</li>
<li>算法的稳定性如何？如果是不稳定的话为什么不稳定？能否改进使其稳定？</li>
<li>算法的平均时间复杂度如何？最好和最坏情况下时间复杂度分别是什么？</li>
<li>算法的额外空间复杂度是多少？ </li>
<li>对于不同数据规模的数据应该如何选择排序算法？</li>
<li>算法在具体代码实现上有什么需要注意的地方？</li>
</ol>
<h1 id="具体排序算法分析及其实现代码"><a href="#具体排序算法分析及其实现代码" class="headerlink" title="具体排序算法分析及其实现代码"></a>具体排序算法分析及其实现代码</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li>基本思想：<br>通过无序区中相邻记录关键字间的比较和位置的交换，使关键字最小的记录如气泡一般逐渐往上“漂浮”直至“水面”。</li>
<li>稳定性：稳定</li>
<li>时间复杂度：<ul>
<li>平均时间复杂度：O(n^2)</li>
<li>最好情况时间复杂度：O(n)，已经按要求排好序，即正序有序，只需要比较n-1次即可（对于下面的改进版本来说），并且无需交换</li>
<li>最坏情况时间复杂度：O(n^2)，逆序有序，需要比较(n-1)+(n-2)+…+1，即nx(n-1)/2次，同时交换nx(n-1)/2次，故时间复杂度为O(n^2)。（注：在实际运行中，比较和交换所需要的时间是不同的，同样的比较n次，但是有的序列可能不需要交换，有的则需要交换n次，虽然算法上时间复杂度的计算相同，但在实际运行中所需时间还是会有差异）</li>
</ul>
</li>
<li>额外空间复杂度：O(1)</li>
<li>示意图如下所示：<br><img src="http://oe0nilvpj.bkt.clouddn.com/Bubble_sort_animation.gif" alt="冒泡排序!"></li>
<li>代码(含递归版本)实现如下所示<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> tmp = arr[i];</div><div class="line">    arr[i] = arr[j];</div><div class="line">    arr[j] = tmp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j + <span class="number">1</span>]) &#123;</div><div class="line">                swap(arr, j, j + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursiveBubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    recursiveBubbleSortWithRange(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursiveBubbleSortWithRange</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">        findMinOfBubbleSort(arr, left, right);</div><div class="line">        recursiveBubbleSortWithRange(arr, left, --right);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findMinOfBubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[i + <span class="number">1</span>]) &#123;</div><div class="line">            swap(arr, i, i + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>冒泡排序有一个很简单的改进措施，就是当一次冒泡过程中，若没有发生交换两个数的情况，则说明序列已经有序，可以直接break，无需进行接下来的比较了。代码如下所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">improvedBubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">if</span> (!flag)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j + <span class="number">1</span>]) &#123;</div><div class="line">                swap(arr, j, j + <span class="number">1</span>);</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><ul>
<li>基本思想：<br>鸡尾酒🍸排序也叫定向冒泡排序，是冒泡排序的一种改进。其余冒泡排序的不同点在于冒泡排序是不断的冒泡过程，而鸡尾酒排序除了冒泡外，还沉底，也就是是冒一个泡，就沉一个底，直到相交为止。鸡尾酒排序可以得到比冒泡排序稍微好一点的性能，因为冒泡排序只从一个方向进行进行比对，每次循环只移动一个项目。</li>
<li>稳定性： 稳定</li>
<li>时间复杂度：<ul>
<li>平均时间复杂度：O(n^2)</li>
<li>最好情况时间复杂度：O(n)，正序有序即可，可以有与冒泡排序采样同样的改进版，只需要比较n-1次</li>
<li>最坏情况时间复杂度：O(n^2)，逆序有序，需要比较nx(n-1)/2次，且同样共需要nx(n-1)/2次交换。</li>
</ul>
</li>
<li>额外空间复杂度：O(1)</li>
<li>示意图如下所示：<br><img src="http://oe0nilvpj.bkt.clouddn.com/ShakeSort.gif" alt="鸡尾酒排序!"></li>
<li>代码实现（含改进版本）：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShakeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[i + <span class="number">1</span>]) &#123;</div><div class="line">                swap(arr, i, i + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        right--;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = right; j &gt; left; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j - <span class="number">1</span>]) &#123;</div><div class="line">                swap(arr, j, j - <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        left++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">improvedShakeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[i + <span class="number">1</span>]) &#123;</div><div class="line">                swap(arr, i, i + <span class="number">1</span>);</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (flag) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        right--;</div><div class="line">        flag = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = right; j &gt; left; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j - <span class="number">1</span>]) &#123;</div><div class="line">                swap(arr, j, j - <span class="number">1</span>);</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (flag) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        left++;</div><div class="line">        flag = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul>
<li>基本思想：<br>选择排序（直接选择排序或简单选择排序）也是很简单直观的，我觉得比冒泡排序还有更好理解，其基本思想就是在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素排序完毕。</li>
</ul>
<p>选择排序需要花费(n-1)+(n-2)+…+1=nx(n-1)/2次比较和n-1次交换操作（当该元素排序前所在的位置恰好是其排序后的位置时，可以理解为自己与自己交换，当然也可以理解为0次交换）。其对初始数据不敏感，无论初始的序列有没有排好序，都需要经历n*(n-1)/2次比较和n-1次交换操作。这对于一些原本排好序，或者近似排好序的序列来说并不具有优势，在最好的情况下，所有都排好序，则需要0次交换，最差则需要n-1次交换。在所有的完全依靠交换去移动元素的排序算法中，选择排序属于比较好的一种。</p>
<p>简单选择排序是不稳定的，举个例子，序列arr={5,8,5,2,9},我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p>
<ul>
<li>稳定性：不稳定</li>
<li>时间复杂度：<ul>
<li>平均时间复杂度：O(n^2)</li>
<li>最好情况时间复杂度：O(n^2)</li>
<li>最坏情况时间复杂度：O(n^2)</li>
</ul>
</li>
<li>额外空间复杂度：O(1)</li>
<li>示意图如下所示：<br><img src="http://oe0nilvpj.bkt.clouddn.com/Selection_sort_animation.gif" alt="选择排序!"><br><img src="http://oe0nilvpj.bkt.clouddn.com/Selection_sort_animation2.gif" alt="选择排序!"></li>
<li>代码实现（含递归版本）如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> minIndex;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">        minIndex = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</div><div class="line">                minIndex = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        swap(arr, minIndex, i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursiveSelectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    recursiveSelectionSortWithRange(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursiveSelectionSortWithRange</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</div><div class="line">        <span class="keyword">int</span> minIndex = findMinIndexOfSelectionSort(arr, left, right);</div><div class="line">        swap(arr, minIndex, right);</div><div class="line">        recursiveSelectionSortWithRange(arr, left, --right);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMinIndexOfSelectionSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> minIndex = left;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;</div><div class="line">            minIndex = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minIndex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul>
<li>基本思想：<br>插入排序（直接插入排序）的工作原理非常类似于我们抓扑克牌。对于未排序数据，在已排序序列中从后往前扫描，找到合适的位置并插入。在实现中，通常采用in-place排序，因而在从后向前扫描过程中，需要反复把已排序好的元素逐个向后挪位，为最新元素提供插入空间。</li>
</ul>
<p>插入排序平均需要(n^2)/4次比较和(n^2)/4次交换，在最坏的情况下即所有元素都逆序排列时需要(n^2)/2次比较和交换，在最好情况下即所有元素都排好序时需要n-1次比较和交换。在插入排序中，元素交换的次数等于序列中逆序元素的对数。而元素比较的次数最少为逆序元素的对数。</p>
<p>总体而言，插入排序对于部分有序序列以及元素个数比较小的序列是一种比较有效的方式。插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。插入排序和冒泡排序相比，虽然时间复杂度都为O(n^2)，但是插入排序的速度直接是逆序对的个数，而冒泡排序中“交换”的次数是逆序对的个数，因此冒泡排序执行的时间至少是逆序对的个数，因此插入排序的执行时间至少比冒泡排序快，所以在元素个数较小时一般选择插入排序而不是冒泡排序。</p>
<p>插入排序的一个简单改进版本是二分查找插入排序，其与前面说的直接插入排序的区别是在查找插入位置时不再是线性地向前扫描查找，而是二分查找插入位置，从而减少查找位置所需要的时间。但是当找到位置后，与直接插入排序一样，需要反复把已排序好的元素逐个向后挪位，所以并不能减少交换位置的次数。当n较大时，总的排序比较次数比直接插入排序的最差情况好得多，但比最差情况要差，所以当元素初始序列已经接近正序有序时，直接插入排序比二分插入排序比较次数少。</p>
<ul>
<li>稳定性：稳定</li>
<li>时间复杂度：<ul>
<li>平均时间复杂度：O(n^2)</li>
<li>最好情况时间复杂度：直接插入排序为O(n)，二分查找插入排序为O(nlogn)</li>
<li>最坏情况时间复杂度：O(n^2)</li>
</ul>
</li>
<li>额外空间复杂度：O(1)</li>
<li>示意图如下所示：<br><img src="http://oe0nilvpj.bkt.clouddn.com/InsertSort.gif" alt="插入排序!"><br><img src="http://oe0nilvpj.bkt.clouddn.com/InsertSort2.gif" alt="插入排序!"><br><img src="http://oe0nilvpj.bkt.clouddn.com/InsertSort3.gif" alt="插入排序!"></li>
<li>代码实现（含二分查找插入排序）如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">int</span> tmp = arr[i];</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; tmp) &#123;</div><div class="line">                <span class="comment">//swap(arr, j - 1, j); 这里swap的作用可以等价于下面的 arr[j - 1] = arr[j];</span></div><div class="line">                arr[j - <span class="number">1</span>] = arr[j];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        arr[j - <span class="number">1</span>] = tmp;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BinaryInsertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> left, right, middle, tmp;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        tmp = arr[i];</div><div class="line">        left = i + <span class="number">1</span>;</div><div class="line">        right = arr.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</div><div class="line">            middle = (left + right) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (tmp &lt; arr[middle]) &#123;</div><div class="line">                left = middle + <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                right = middle - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; right; j++) &#123;</div><div class="line">            arr[j] = arr[j + <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        arr[right] = tmp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ul>
<li>基本思想：<br>希尔排序也叫递减增量排序或壳排序，是插入排序的一种更高效的改进版本，因DL. Shell于1959年提出而得名。希尔排序是基于插入排序的两点性质进行改进的。<ul>
<li>一是插入排序在对几乎已经排好序的数据操作时，效率高，可以达到线性排序的效率。</li>
<li>二是插入排序一般是低效的，因为插入排序每次只能讲数据移动一位。</li>
</ul>
</li>
</ul>
<p>基于这两点，希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步时，需排序的数据几乎是已排序好了的，可以很快完成。</p>
<p>比如有一个很小的数据在一个已按升序排好序的序列的末端。如果用复杂度为O(N^2)的排序（比如冒泡排序或者直接插入排序），可能会进行n次的比较和交换才能将数据移动到正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p>
<p>希尔排序的步长可以随意指定，只要保证最后的步长为1即可。一个比较通用步长选择较多的是Knuth提出的，为h=h*3+1，初始h取1，对应的递减为h=(h-1)/3，直到h=1为止。希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量平均时间复杂度为O(n^2)，而Hibbard增量的希尔排序平均时间复杂度为O(n^(5/4))，但是现今仍然没有人能找出希尔排序的精确下界。</p>
<p>希尔排序是不稳定的，原因是虽然在同一个分组内元素之间的相对顺序能够保证，但是不同分组内的元素相对顺序不能保证，比如在arr={5,1,4,6,9,5,3,7}中，按从大到小排序，当步长为4时，第一个5与9是同一组，所以第一个5与9交换位置，第2个5则是与前面的1一组，也需要交换位置，所以一次排序后变为{9,5,4,7,5,1,3,6}，第一个5与第二个5的相对位置发生了改变。</p>
<ul>
<li>稳定性：不稳定</li>
<li>时间复杂度：<ul>
<li>平均时间复杂度：O(nlogn)~O(n^2)</li>
<li>最好情况时间复杂度：O(n^1.3)</li>
<li>最坏情况时间复杂度：O(n^2)</li>
</ul>
</li>
<li>额外空间复杂度：O(1)</li>
<li>示意图如下所示：<br><img src="http://oe0nilvpj.bkt.clouddn.com/Sorting_shellsort_anim.gif" alt="希尔排序!"><br><img src="http://oe0nilvpj.bkt.clouddn.com/Sorting_shellsort_anim2.gif" alt="希尔排序!"></li>
<li>代码实现如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (h &lt;= arr.length) &#123;</div><div class="line">        h = h * <span class="number">3</span> + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (h &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; arr.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> j = i - h;</div><div class="line">            <span class="keyword">int</span> tmp = arr[i];</div><div class="line">            <span class="keyword">while</span> (j &gt;=<span class="number">0</span> &amp;&amp; arr[j] &lt; tmp) &#123;</div><div class="line">                arr[j + h] = arr[j];</div><div class="line">                j = j - h;</div><div class="line">            &#125;</div><div class="line">            arr[j + h] = tmp;</div><div class="line">        &#125;</div><div class="line">        h = (h - <span class="number">1</span>) / <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="锦标赛排序"><a href="#锦标赛排序" class="headerlink" title="锦标赛排序"></a>锦标赛排序</h2><ul>
<li>基本思想：<br>竞标赛排序也叫树型排序，也叫胜者树。直接选择排序之所以不够高效是因为没有把前一趟比较的结果保存下来，每一趟都有太多重复的比较。锦标赛排序则克服了这一缺点，它的基本思想与体育淘汰赛类似，首先进行两两比较，得到n/2个比较的胜者，然后作为第一次比较的结果保存下来，然后对这些元素再进行两两比较，如此重复，直到找到最大的对象为止。</li>
</ul>
<p>竞标赛排序首先需要建立一棵满二叉树，如果不够2的幂次方，则需要补一些元素。假设arr为待排序列，则arr的元素都分布在叶子节点上，而两个节点的父节点则存储着比赛的胜者。同时我们需要一个变量来存储胜者的索引。在每次得到最终胜者时，我们可以得到胜者的索引号。然后将该胜者替换为最小值，当我们需要在剩下的找到最大时，只需要沿着之前胜者所在的父节点不断向上比较，更新其父节点的胜者索引号即可。只需要O(logn)次比较即可。所以，除了第一次需要比较n-1次之外，其余每次都只需要logn次比较，所以时间复杂度为O(nlogn)。但是对于n各待排元素，锦标赛排序算法需要至少2n-1个节点来存放胜者树，所以这是典型的空间换时间的算法。</p>
<p>竞标赛排序非常适合一个在很大的序列中查找前k个（k较小）元素，只需要n-1 + klogn次比较即可。</p>
<ul>
<li>稳定性：稳定</li>
<li>时间复杂度：<ul>
<li>平均时间复杂度：O(nlogn)</li>
<li>最好情况时间复杂度：O(nlogn)</li>
<li>最坏情况时间复杂度：O(nlogn)</li>
</ul>
</li>
<li>额外空间复杂度：O(n)</li>
<li>示意图如下（前3步）所示：<br><img src="http://oe0nilvpj.bkt.clouddn.com/%E9%94%A6%E6%A0%87%E8%B5%9B1.png" alt="锦标赛排序!"><br><img src="http://oe0nilvpj.bkt.clouddn.com/%E9%94%A6%E6%A0%87%E8%B5%9B2.png" alt="锦标赛排序!"><br><img src="http://oe0nilvpj.bkt.clouddn.com/%E9%94%A6%E6%A0%87%E8%B5%9B3.png" alt="锦标赛排序!"></li>
<li>代码实现如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用Node存储竞赛排序过程中的节点，包括数据和数据在数组中的索引</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当去除最大元素以后，需要调整数组</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Adjust</span><span class="params">(Node[] data, <span class="keyword">int</span> idx)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span>(idx != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 当前id是奇数，说明并列的是idx + 1， 父节点是 (idx-1)/2</span></div><div class="line">        <span class="keyword">if</span>(idx % <span class="number">2</span> == <span class="number">1</span>) &#123;</div><div class="line">            data[(idx - <span class="number">1</span>) / <span class="number">2</span>] = data[idx].data &gt; data[idx + <span class="number">1</span>].data ? data[idx] : data[idx + <span class="number">1</span>];</div><div class="line">            idx = (idx - <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前id是偶数，说明并列的是idx - 1， 父节点是 idx / 2 - 1</span></div><div class="line">            data[idx / <span class="number">2</span> - <span class="number">1</span>] = data[idx-<span class="number">1</span>].data &gt; data[idx].data ? data[idx-<span class="number">1</span>] : data[idx];</div><div class="line">            idx = (idx / <span class="number">2</span> - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TournamentSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> nNodes = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> nTreeSize;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(nNodes &lt; arr.length) &#123;</div><div class="line">        nNodes *= <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 竞赛树节点的个数, 是满二叉树</span></div><div class="line">    nTreeSize = <span class="number">2</span> * nNodes - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 竞赛树用数组存储</span></div><div class="line">    Node[] nodes = <span class="keyword">new</span> Node[nTreeSize];</div><div class="line"></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> idx;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化竞赛树数据, 一共是 nNodes个叶节点</span></div><div class="line">    <span class="keyword">for</span>(i = nNodes - <span class="number">1</span>; i &lt; nTreeSize; i++) &#123;</div><div class="line">        idx = i - (nNodes - <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span>(idx &lt; arr.length) &#123;</div><div class="line">            nodes[i] = <span class="keyword">new</span> Node(arr[idx], i);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 对于补充的数据，我们初始化成最小。</span></div><div class="line">            nodes[i] = <span class="keyword">new</span> Node(Integer.MIN_VALUE, -<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 共有nNodes -1个非叶节点</span></div><div class="line">    <span class="keyword">for</span>(i = nNodes - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</div><div class="line">        nodes[i] = <span class="keyword">new</span> Node();</div><div class="line">        <span class="keyword">if</span>(nodes[i * <span class="number">2</span> + <span class="number">1</span>].data &gt; nodes[i * <span class="number">2</span> + <span class="number">2</span>].data) &#123;</div><div class="line">            nodes[i] = nodes[i*<span class="number">2</span> + <span class="number">1</span>];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            nodes[i] = nodes[i*<span class="number">2</span> + <span class="number">2</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 实际排序的过程</span></div><div class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; arr.length; i++)</div><div class="line">    &#123;</div><div class="line">        arr[i] = nodes[<span class="number">0</span>].data;</div><div class="line">        nodes[nodes[<span class="number">0</span>].id].data = Integer.MIN_VALUE;</div><div class="line">        Adjust(nodes, nodes[<span class="number">0</span>].id);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li>基本思想：<br>堆排序的定义如下：n个元素的序列，当且经当满足“任何一个非终端节点的值都大于等于（或小于等于）其左右孩子的值”时，才能称之为堆。因此，堆顶必为期最大值（或最小值）。若在输出堆顶的最小值之后，使得剩余n-1个元素重建一个堆，则得到n个元素中的次小值。如此反复执行，便能得到一个有序序列，这个过程称之为堆排序。</li>
</ul>
<p>于是，堆排序有2个问题需要解决：</p>
<ol>
<li>如何由一个无需序列建成一个堆？</li>
<li>如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</li>
</ol>
<p>问题1的解决方法是：从一个无序序列建堆的过程就是一个反复“筛选”的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是第n/2向下取整个元素，由此筛选的位置只要从第n/2向下取整个元素开始。</p>
<p>堆排序在对海量数据的Top K问题中有广泛应用，其与锦标赛排序的有点在于额外空间复杂度为O(1)。比如从10亿个浮点数中，选出其中最大的10000个。则可以用建立一个10000个数的最小堆，然后将10亿个数依次读取，大于堆顶，则替换堆顶，做一次堆调整。结束之后，最小堆中存放的数即为所求。总的时间复杂度为nlogk，这里n为10亿，k为10000。</p>
<p>堆排序之所以不稳定是在当把堆顶元素与最后一个元素交换时，可能会改变相同元素的相对位置。比如序列是10，20，30，20，按最小堆的先输出堆顶10，然后将第3层的20（第2个20）放到堆顶，符合最小堆的要求，不需要调整，所以就输出第2个20，稳定性遭到了破坏。</p>
<ul>
<li>稳定性：不稳定</li>
<li>时间复杂度：<ul>
<li>平均时间复杂度：O(nlogn)</li>
<li>最好情况时间复杂度：O(nlogn)</li>
<li>最坏情况时间复杂度：O(nlogn)，相比于快速排序来说，这是堆排序的最大优点</li>
</ul>
</li>
<li>额外空间复杂度：O(1)</li>
<li>示意图如下所示：<br><img src="http://oe0nilvpj.bkt.clouddn.com/heapsort_anim.gif" alt="堆排序!"></li>
<li>代码实现如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    buildHeap(arr);</div><div class="line">    <span class="keyword">int</span> heapSize = arr.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">        swap(arr, <span class="number">0</span>, i);</div><div class="line">        heapify(arr, <span class="number">0</span>, --heapSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        heapify(arr, i, arr.length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> smallest = i;</div><div class="line">    <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; arr[left] &lt; arr[i]) &#123;</div><div class="line">        smallest = left;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; arr[right] &lt; arr[smallest]) &#123;</div><div class="line">        smallest = right;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (smallest != i) &#123;</div><div class="line">        swap(arr, i, smallest);</div><div class="line">        heapify(arr, smallest, heapSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li>基本思想：<br>快速排序是对冒泡排序的一种改进，由A.R.Hoare在1962年提出。冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序则是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面（有没有点鸡尾酒的味道？）。其基本思想是先选择一个基准元素pivot，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比pivot要小（或等于），而另外一部分的所有数据比pivot要大（或等于），然后再按此方法对这两部分数据分别进行快速排序，整个过程可以递归进行，以此达到整体有序。</li>
</ul>
<p>快速排序的魅力之处在于它能在每次partition（排序算法的核心所在）都能为一个数组元素确定其排序最终正确位置（一次就定位准，下次循环就不需要考虑这个元素了）。而对于每次partition中基准元素pivot的选择通常是第一个元素或者最后一个元素，也可以随机选择一个元素作为pivot。</p>
<p>事实上，快速排序通常明显比其他O(nlogn)的算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来，且在大部分真实世界的数据，可以决定设计的旋转，减少所需时间的二次方项的可能性。</p>
<p>快速排序是不稳定的。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为arr={5,3,3,4,3,8,9,10,11},现在中枢元素5（选取第一个元素为pivot）和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，不稳定发生在中枢元素和a[j] 交换的时刻。</p>
<ul>
<li>稳定性：不稳定</li>
<li>时间复杂度：<ul>
<li>平均时间复杂度：O(nlogn)</li>
<li>最好情况时间复杂度：O(nlogn)</li>
<li>最坏情况时间复杂度：O(n^2)，即数组已经排好序的情况（在选取最后一个元素为pivot基准元素时），可以通过随机化来进行改进（shuffle array 或者randomized select pivot），使得期望运行时间为O(nlogn)。“A killer adversary for quicksort”这篇文章很有趣地介绍了怎么样设计一个输入数组，使得快速排序的运行时间为O(n^2)。</li>
</ul>
</li>
<li>额外空间复杂度：O(logn)~O(n)</li>
<li>示意图如下所示：<br><img src="http://oe0nilvpj.bkt.clouddn.com/quicksort_anim.gif" alt="快速排序!"></li>
<li>代码实现如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    recursiveQuickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursiveQuickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</div><div class="line">        <span class="keyword">int</span> p = partition(arr, left, right);</div><div class="line">        recursiveQuickSort(arr, left, p - <span class="number">1</span>);</div><div class="line">        recursiveQuickSort(arr, p + <span class="number">1</span>, right);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> pivot = arr[right];</div><div class="line">    <span class="keyword">int</span> i = left - <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt; right; j++) &#123;</div><div class="line">        <span class="keyword">if</span> (arr[j] &gt;= pivot) &#123;</div><div class="line">            i++;</div><div class="line">            swap(arr, i, j);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    swap(arr, i + <span class="number">1</span>, right);</div><div class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li>基本思想：<br>归并排序是分而治之的思想，所谓分而治之，就是将原问题分解为多个独立的子问题，且这些子问题的形式和原问题相似，只是规模上减少了，求解完子问题后合并结果构成原问题的解。分而治之通常分为3步：Divide（分解子问题），Conquer（递归解决子问题），Combine（子问题解求出来后合并成原问题解的步骤）。假设Divide需要f(n)时间，Conquere分解为b个子问题，且子问题大小为a，Combine需要g(n)个时间，则递归式为：T(n) = bT(n/a)+f(n)+g(n)。在归并排序中，Divede的步骤为int middle = (left + right) / 2，因此为O(1)，Combine则为merge函数，Conquer步骤分解为2个子问题，子问题大小为n/2，因此归并排序的递归式为T(n) = 2T(n/2) + O(n)。</li>
</ul>
<p>归并排序相比于其他排序算法的一个缺点是其需要申请额外存储空间来存放合并后的序列，即额外空间复杂度为O(n)。而其优点则很明显，当数据量足够大以至于内存无法存储时，可以通过归并排序来进行，在每次归并完成后将结果存储在磁盘中。</p>
<ul>
<li>稳定性：稳定</li>
<li>时间复杂度：<ul>
<li>平均时间复杂度：O(nlogn)</li>
<li>最好情况时间复杂度：O(nlogn)</li>
<li>最坏情况时间复杂度：O(nlogn)</li>
</ul>
</li>
<li>额外空间复杂度：O(n)</li>
<li>示意图如下所示：<br><img src="http://oe0nilvpj.bkt.clouddn.com/Merge_sort_animation.gif" alt="快速排序!"></li>
<li>代码实现如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</div><div class="line">    MergeSortWithRange(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, newArray);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSortWithRange</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] newArr)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</div><div class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</div><div class="line">        MergeSortWithRange(arr, left, middle, newArr);</div><div class="line">        MergeSortWithRange(arr, middle + <span class="number">1</span>, right, newArr);</div><div class="line">        merge(arr, left, middle, right, newArr);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] newArr)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> lowStart = left;</div><div class="line">    <span class="keyword">int</span> lowEnd = mid;</div><div class="line">    <span class="keyword">int</span> hightStart = mid + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> highEnd = right;</div><div class="line">    <span class="keyword">while</span> (lowStart &lt;= lowEnd &amp;&amp; hightStart &lt;= highEnd) &#123;</div><div class="line">        <span class="keyword">if</span> (arr[lowStart] &gt; arr[hightStart]) &#123;</div><div class="line">            newArr[index++] = arr[lowStart++];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            newArr[index++] = arr[hightStart++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (lowStart &lt;= lowEnd) &#123;</div><div class="line">        newArr[index++] = arr[lowStart++];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (hightStart &lt;= highEnd) &#123;</div><div class="line">        newArr[index++] = arr[hightStart++];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</div><div class="line">        arr[left + i] = newArr[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ul>
<li><p>基本思想：<br>基数排序也是基于非比较的整数排序算法。其原理是将整数切割成不同的数字，然后按每个位数分别比较。因为整数可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能用于整数。基数排序的时间复杂度为O(kn)，其中n为排序元素个数，k为数字位数。其不一定优于O(nlogn)的算法，因为k的大小会受到n的影响。</p>
</li>
<li><p>稳定性：稳定</p>
</li>
<li>时间复杂度：<ul>
<li>平均时间复杂度：O(kn)，其中n为排序元素个数，k为数字位数</li>
<li>最好情况时间复杂度：O(kn)，其中n为排序元素个数，k为数字位数</li>
<li>最坏情况时间复杂度：O(kn)，其中n为排序元素个数，k为数字位数</li>
</ul>
</li>
<li>额外空间复杂度：O(n)</li>
<li>示意图如下所示：<br><img src="http://oe0nilvpj.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E4%BE%8B%E5%AD%90.png" alt="基数排序!"></li>
<li>代码实现如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">    <span class="comment">// 得到最大的数</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</div><div class="line">            max = arr[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 得到最大的数的位数</span></div><div class="line">    <span class="keyword">int</span> times = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (max &gt; <span class="number">0</span>) &#123;</div><div class="line">        times++;</div><div class="line">        max = max / <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 创建10个链表来存储</span></div><div class="line">    List&lt;ArrayList&gt; queue = <span class="keyword">new</span> ArrayList&lt;ArrayList&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        ArrayList&lt;Integer&gt; q = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        queue.add(q);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 从个位开始，对每一位进行一次排序</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</div><div class="line">        <span class="comment">// 加入该位的数字对应的queue中</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</div><div class="line">            <span class="keyword">int</span> digit = arr[j] % (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, (i + <span class="number">1</span>)) / (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i);</div><div class="line">            ArrayList&lt;Integer&gt; tmp = queue.get(digit);</div><div class="line">            tmp.add(arr[j]);</div><div class="line">            queue.set(digit, tmp);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 将10个队列中的数排好放到arr中</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">9</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">            <span class="keyword">while</span> (queue.get(j).size() &gt; <span class="number">0</span>)&#123;</div><div class="line">                ArrayList&lt;Integer&gt; q = queue.get(j);</div><div class="line">                arr[count++] = q.get(<span class="number">0</span>);</div><div class="line">                q.remove(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><ul>
<li>基本思想：<br>计数排序使用一个额外的数组C，其中第i个元素是待排序序列arr中值等于i的元素的个数。然后根据数组C将arr中的元素排到正确的位置。它只能对整数进行排序。</li>
</ul>
<p>计数排序不是基于比较的排序，排序的速度快于任何比较排序算法。且计数的数组C的长度取决于待排序数组中数据的范围（最大值与最小值的差加1），这使得计数排序对于数据范围很大的数组，需要大量时间和空间。</p>
<ul>
<li>稳定性：因为是计数，说不清楚</li>
<li>时间复杂度：<ul>
<li>平均时间复杂度：当输入为n个0到k之间的整数时，为O(n+k)</li>
<li>最好情况时间复杂度：当输入为n个0到k之间的整数时，为O(n+k)</li>
<li>最坏情况时间复杂度：当输入为n个0到k之间的整数时，为O(n+k)</li>
</ul>
</li>
<li>额外空间复杂度：当输入为n个0到k之间的整数时，为O(k)，即数组C的大小</li>
<li>代码实现如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (max &lt; arr[i]) &#123;</div><div class="line">            max = arr[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[] C = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">        C[arr[i]]++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = max; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C[i]; j++) &#123;</div><div class="line">            arr[k++] = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><ul>
<li>基本思想：<br>桶排序也称为箱排序，其工作原理是将数组分到有限数量的桶子里。每个桶子再分别排序（有可能使用其他的排序算法或以递归方式继续使用桶排序进行排序）。桶排序在很多情况下比快排还要快，但是缺点是非常耗空间，基本上也是最耗空间的一种排序算法，而且只能在某些强行下使用。</li>
</ul>
<p>桶排序最好情况下使用线性时间O(n)，且桶排序的时间复杂度取决于各个桶之间的数据进行排序的时间复杂度，因为其他部分的时间复杂度都为O(n)。同时，很显然的是桶划分的越小，各个桶之间的数据越少，排序所用时间也会越少，但相应的空间就会增大。</p>
<p>桶排序在处理密集型数据排序的时候有比较好的效果，因为密集型数据情况下的桶排序的额外空间复杂度不高。比如浙江省的高考成绩在0~810分之间，有将近30万考生，我们可以创建811个桶，将每个考生的分数放入对应的桶中，这样将极大提高排序的时间。但是如果分数是从0~1亿分，那分1亿个桶是不现实的，所以桶排序有其局限性。桶排序还有一个关键点就是桶的设计以及hash函数的设计，如果设计不好的话几乎没有作用。</p>
<ul>
<li>稳定性：由桶内排序算法决定</li>
<li>时间复杂度：<ul>
<li>平均时间复杂度：取决于各个桶之间进行排序的时间复杂度</li>
<li>最好情况时间复杂度：取决于各个桶之间进行排序的时间复杂度</li>
<li>最坏情况时间复杂度：取决于各个桶之间进行排序的时间复杂度</li>
</ul>
</li>
<li>额外空间复杂度：O(n)</li>
<li>代码实现如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//设置桶的数量为100，并规定待排数[0,1000)</span></div><div class="line">    <span class="keyword">int</span> bucketNums = <span class="number">100</span>;</div><div class="line">    <span class="comment">// 创建</span></div><div class="line">    List&lt;List&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNums; i++) &#123;</div><div class="line">        <span class="comment">//用链表比较合适</span></div><div class="line">        buckets.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//划分桶</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">        buckets.get(mapFunctionOfBucketSort(arr[i])).add(arr[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//对每个桶进行排序</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.size(); i++) &#123;</div><div class="line">        <span class="keyword">if</span>(!buckets.get(i).isEmpty()) &#123;</div><div class="line">            Collections.sort(buckets.get(i));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//还原排好序的数组</span></div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = buckets.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = buckets.get(i).size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">            arr[index++] = buckets.get(i).get(j);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mapFunctionOfBucketSort</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> x / <span class="number">100</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于稳定性的判定，有一个简单的比较通用的结论就是需要交换两个不相邻元素的排序算法通常是不稳定的，比如快速排序，希尔排序，堆排序等。</p>
<p>而将不稳定的算法改为稳定的算法一个最简单的方法是在原来的数据中加入其在初始未排序数组中的索引，当排序完成后，对相等的元素再按其在未排序数组中的索引再排序一次。</p>
<p>排序算法博大精深，需要深入理解每一个算法的思想并学会灵活运用，针对待排序序列的特点，寻找合适的排序算法，亦或是将不同的排序算法组合起来共同完成排序任务。</p>
<p>再看一遍吧~<br><img src="http://oe0nilvpj.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.png" alt="排序算法总结!"></p>
<p>参考：<br><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95</a><br><a href="http://blog.csdn.net/xiazdong/article/details/8193625" target="_blank" rel="external">http://blog.csdn.net/xiazdong/article/details/8193625</a><br><a href="http://blog.csdn.net/xiazdong/article/details/8462393" target="_blank" rel="external">http://blog.csdn.net/xiazdong/article/details/8462393</a><br><a href="http://www.cnblogs.com/eniac12/p/5329396.html" target="_blank" rel="external">http://www.cnblogs.com/eniac12/p/5329396.html</a><br><a href="http://www.runoob.com/w3cnote/sort-algorithm-summary.html" target="_blank" rel="external">http://www.runoob.com/w3cnote/sort-algorithm-summary.html</a><br><a href="http://www.cnblogs.com/wxisme/p/5243631.html" target="_blank" rel="external">http://www.cnblogs.com/wxisme/p/5243631.html</a><br><a href="http://blog.csdn.net/zgrjkflmkyc/article/details/11639091" target="_blank" rel="external">http://blog.csdn.net/zgrjkflmkyc/article/details/11639091</a><br><a href="http://www.jianshu.com/p/042b5e5dc040" target="_blank" rel="external">http://www.jianshu.com/p/042b5e5dc040</a><br><a href="http://blog.csdn.net/han_xiaoyang/article/details/12163251" target="_blank" rel="external">http://blog.csdn.net/han_xiaoyang/article/details/12163251</a><br><a href="http://www.atool.org/sort.php" target="_blank" rel="external">http://www.atool.org/sort.php</a><br><a href="http://blog.csdn.net/litong09282039/article/details/46332127" target="_blank" rel="external">http://blog.csdn.net/litong09282039/article/details/46332127</a><br><a href="http://yingyingol.iteye.com/blog/1334891" target="_blank" rel="external">http://yingyingol.iteye.com/blog/1334891</a><br><a href="http://www.myexception.cn/program/1404520.html" target="_blank" rel="external">http://www.myexception.cn/program/1404520.html</a></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/12/17/十八般排序算法，样样精通/">十八般排序算法，样样精通</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">Bigming</a></p>
        <p><span>发布时间:</span>2016-12-17, 13:56:25</p>
        <p><span>最后更新:</span>2016-12-27, 21:54:00</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/12/17/十八般排序算法，样样精通/" title="十八般排序算法，样样精通">http://bigmingtalk.github.io/2016/12/17/十八般排序算法，样样精通/</a>
            <span class="copy-path" data-clipboard-text="原文: http://bigmingtalk.github.io/2016/12/17/十八般排序算法，样样精通/　　作者: Bigming" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/12/26/深入理解红黑树及TreeMap源码实现/">
                    深入理解红黑树及TreeMap源码实现
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/12/13/深入浅出数据结构之栈与队列[例子，技巧与使用场景]/">
                    深入浅出数据结构之栈与队列[例子，技巧与使用场景]
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#排序算法特征"><span class="toc-number">1.</span> <span class="toc-text">排序算法特征</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#是否是基于比较的排序算法"><span class="toc-number">1.1.</span> <span class="toc-text">是否是基于比较的排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序过程能否全部记录放在内存中完成"><span class="toc-number">1.2.</span> <span class="toc-text">排序过程能否全部记录放在内存中完成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序算法的稳定性"><span class="toc-number">1.3.</span> <span class="toc-text">排序算法的稳定性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序算法的时间复杂度"><span class="toc-number">1.4.</span> <span class="toc-text">排序算法的时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序算法的额外空间复杂度"><span class="toc-number">1.5.</span> <span class="toc-text">排序算法的额外空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#具体排序算法分析及其实现代码"><span class="toc-number">2.</span> <span class="toc-text">具体排序算法分析及其实现代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#冒泡排序"><span class="toc-number">2.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#鸡尾酒排序"><span class="toc-number">2.2.</span> <span class="toc-text">鸡尾酒排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择排序"><span class="toc-number">2.3.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插入排序"><span class="toc-number">2.4.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#希尔排序"><span class="toc-number">2.5.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锦标赛排序"><span class="toc-number">2.6.</span> <span class="toc-text">锦标赛排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆排序"><span class="toc-number">2.7.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快速排序"><span class="toc-number">2.8.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#归并排序"><span class="toc-number">2.9.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基数排序"><span class="toc-number">2.10.</span> <span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计数排序"><span class="toc-number">2.11.</span> <span class="toc-text">计数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#桶排序"><span class="toc-number">2.12.</span> <span class="toc-text">桶排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-6 i,
        .toc-level-6 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"十八般排序算法，样样精通　| Bigming　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
        <div class="addthis_sharing_toolbox"></div>
    
</div>







    
      <div class="duoshuo" id="comments">
    <div id="comment-box" ></div>
    <div class="ds-thread" id="ds-thread" data-thread-key="2016/12/17/十八般排序算法，样样精通/" data-title="十八般排序算法，样样精通" data-url="http://bigmingtalk.github.io/2016/12/17/十八般排序算法，样样精通/"></div>
    <script>
        var duoshuoQuery = {short_name:"bigming"};
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            s.async = true; s.charset = 'UTF-8';
            (d.head || d.body).appendChild(s);
        }

        
    </script>
    
    <script> loadComment(); </script>

</div>
    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/12/26/深入理解红黑树及TreeMap源码实现/" title="上一篇: 深入理解红黑树及TreeMap源码实现">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/12/13/深入浅出数据结构之栈与队列[例子，技巧与使用场景]/" title="下一篇: 深入浅出数据结构之栈与队列[例子，技巧与使用场景]">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/19/数组划分成不含相同元素子数组问题/">数组划分成不含相同元素子数组问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/18/操作系统之进程及异常控制流/">操作系统之进程及异常控制流</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/17/简单说说链接器和链接过程/">简单说说链接器和链接过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/16/深入浅出理解高速缓存及多路组相联/">深入浅出理解高速缓存及多路组相联</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/16/计算机存储层次结构概览/">计算机存储层次结构概览</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/15/整数与浮点数在计算机中的表示与计算/">整数与浮点数在计算机中的表示与计算</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/14/程序员角度看计算机系统/">程序员角度看计算机系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/09/Fibonacci数列的O-logn-解法/">Fibonacci数列的O(logn)解法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/04/Java容器（Java-Collection-Framework）总览/">Java容器（Java Collection Framework）总览</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/28/说说B-树，B-树，B-树/">说说B-树，B+树，B*树</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/27/深入浅析理解AVL树[含代码实现]/">深入浅析理解AVL树[含代码实现]</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/26/说说卡特兰数/">说说卡特兰数</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/26/深入理解红黑树及TreeMap源码实现/">深入理解红黑树及TreeMap源码实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/17/十八般排序算法，样样精通/">十八般排序算法，样样精通</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/13/深入浅出数据结构之栈与队列[例子，技巧与使用场景]/">深入浅出数据结构之栈与队列[例子，技巧与使用场景]</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/06/Java源码解读之Integer/">Java源码解读之Integer及自动装箱拆箱</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/05/Java中Object类源代码详解(转)/">Java中Object类源代码详解(转)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/05/谈谈Java的native关键字以及JNI调用和实现/">谈谈Java的native关键字以及JNI调用和实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/01/说说Java中的静态内部类/">说说Java中的静态内部类</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/11/Java传值还是传引用？读完这篇文章你就懂了！/">Java传值还是传引用？读完这篇文章你就懂了！</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/09/Java中的字符编码，代码点与代码单元/">Java中的字符编码，代码点与代码单元</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/04/Java中private方法能重写吗？/">Java中private方法能重写吗？</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/21/有的没的，写下来的才是你的/">有的没的，写下来的才是你的</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2017 Bigming
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
             post: ".article-entry a[href], .copyright a[href]", 
            
            
            
            
            
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>